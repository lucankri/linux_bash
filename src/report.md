## 1. Установка ОС

* команда узнать версию Ubuntu
![](./screen/screen1.png)

## 2. Создание пользователя
* команда создание пользователя
![](./screen/screen2.png)

* вывод команды cat /etc/passwd
![](./screen/screen3.png)

## 3. Настройка сети ОС
* Задаем название машины вида user-1
    * открываем файл hostname через vim
    ![](./screen/screen4.png)

    * меняем название машины
    ![](./screen/screen5.png)

    * смотрим изменения
    ![](./screen/screen6.png)

* Устанавливаем временную зону, соответствующую нашему текущему местоположению
    * команда для смены временной зоны
    ![](./screen/screen7.png)

    * проверяем временную зону
    ![](./screen/screen8.png)

* Выводим названия сетевых интерфейсов с помощью консольной команды
    ![](./screen/screen9.png)

    * lo - это специальный виртуальный сетевой интерфейс, который ваш компьютер использует для связи с самим собой. Он используется в основном для диагностики и устранения неполадок, а также для подключения к серверам, работающим на локальном компьютере.

<br/>

* Команда что бы получить ip адрес устройства, на котором вы работаете, от DHCP сервера.
![](./screen/screen10.png)

    * DHCP - (Dynamic Host Configuration Protocol — протокол динамической настройки узла) — прикладной протокол, позволяющий сетевым устройствам автоматически получать IP-адрес и другие параметры, необходимые для работы в сети TCP/IP

<br/>

* Выводим на экран внешний ip-адрес шлюза (ip) и внутренний IP-адрес шлюза, он же ip-адрес по умолчанию (gw)

    * внешний ip-адресс шлюза
    ![](./screen/screen11.png)

    * внутренний ip-адресс шлюза, он же по умолчанию
    ![](./screen/screen12.png)

* Задаем статичные (заданные вручную, а не полученные от DHCP сервера) настройки ip, gw, dns (использовать публичный DNS серверы, например 1.1.1.1 или 8.8.8.8)

    * заходим в файл конфигурации с помощью редактора (в данном случае vim)<br/>
    `sudo vim /etc/netplan/00-installer-config.yaml`

    * редактируем файл конфигурации
    ![](./screen/screen13.png)

* Перезагружаем виртуальную машину командой: `reboot`. <br/>Убеждаемся, что статичные сетевые настройки (ip, gw, dns) соответствуют заданным в предыдущем пункте.
    * "пингуем" 1.1.1.1
    ![](./screen/screen14.png)

    * "пингуем" ya.ru
    ![](./screen/screen15.png)

## 4. Обновление ОС
* Обновляем системные пакеты до последней на момент выполнения задания версии.
    * что бы правильно обновить ОС нам нужно выполнить 2 команды
        * 1: `sudo apt-get update` - команда update используется для синхронизации индекса пакетов из репозиториев
        * 2: `sudo apt-get upgrade` - команда upgrade используется для установки самых новых версий пакетов, установленных в системе (т.е. выполняет обновление)
    * убедимся что мы обновлены до последней версии
    ![](./screen/screen16.png)

## 5. Использование команды sudo
* Разрешаем пользователю, созданному в Part 2, выполнять команду sudo
    * нужно пользователя добавить в группу sudo командой: `sudo usermod -a -G sudo <имя пользователя>`
    ![](./screen/screen17.png)

    * sudo - (Substitute User and do) программа для системного администрирования UNIX-систем. Главное назначение sudo — это выполнить команду от имени другого пользователя, обычно от root. Смысл выполнения команды от root в том, что у него повышенные права доступа и, применяя sudo, обычный пользователь может выполнить те действия, на которые у него недостаточно прав.

    * делаем смену пользователя командой: `sudo su <имя пользователя>`
    ![](./screen/screen18.png)

    * Меняем hostname ОС c помощью редактора (в данном случае vim) от имени пользователя, созданного в пункте Part 2 (используя sudo)
    ![](./screen/screen19.png)

    * результат
    ![](./screen/screen20.png)

## 6. Установка и настройка службы времени
* Настраиваем службу автоматической синхронизации времени
    * с помощью команды `sudo timedatectl set-ntp on`

    * выводим время командой `timedatectl show`
    ![](./screen/screen21.png)

## 7. Установка и использование текстовых редакторов
* Устанавливаем текстовые редакторы VIM (+ любые два по желанию NANO, MCEDIT, JOE и т.д.)
    * в нашем случае vim и nano уже установлены, но команды для установки я оставлю, остается установить только JOE или MCEDIT.<br/>Команды:
        * установка vim: `sudo apt install vim`
        * установка nano: `sudo apt install nano`
        * установка JOE: `sudo apt install joe`

    * Используем каждый из трех выбранных редакторов, создаем файл test_X.txt, где X -- название редактора, в котором создан файл. Напишите в нём свой никнейм, закрываем файл с сохранением изменений.
        * скриншот редактора vim с содержимым файла
        ![](./screen/screen22.png)
        > что бы выйти из редактора с сохранением файла нужно:<br/>
        1: если находимся в режиме редактирования - выйти из него нажав клавишу `esc`<br/>
        2: нажать `:` - наш курсор переместиться вниз (в командную строку) и напечатает `:`<br/>
        3: набрать клавиши `wq` - в итоге получится `:wq` и нажать enter<br/><br/>
        Таким образом мы выйдем из редактора и сохраним файл

        * скриншот редактора nano с содержимым файла
        ![](./screen/screen23.png)
        > что бы выйти из редактора с сохранением файла нужно:<br/>
        1: для выхода из редактора нужно нажать сочание клавиш `control + x`<br/>
        2: когда мы выходим из редактора, он предложит нам сохранить файл если в нем были сделданны изменения и нужно нажать `y`, и `enter`

        * скриншот редактора joe с содержимым файла
        ![](./screen/screen24.png)
        > что бы выйти из редактора с сохранением файла нужно:<br/>
        1: для выхода из редактора нужно нажать сочание клавиш `control + k` и `q`<br/>
        2: когда мы выходим из редактора, он предложит нам сохранить файл если в нем были сделданны изменения и нужно нажать `y`

    * Используем каждый из трех выбранных редакторов, открываем файл на редактирование, отредактируем файл, заменив никнейм на строку "21 School 21", закрываем файл без сохранения изменений.
        * скриншот редактора vim с содержимым файла
        ![](./screen/screen25.png)
        > что бы выйти из редактора без сохранения файла нужно:<br/>
        1: если находимся в режиме редактирования - выйти из него нажав клавишу `esc`<br/>
        2: нажать `:` - наш курсор переместиться вниз (в командную строку) и напечатает `:`<br/>
        3: набрать клавиши `q!` - в итоге получится `:q!` и нажать enter<br/><br/>
        Таким образом мы выйдем из редактора без сохрания файла

        * скриншот редактора nano с содержимым файла
        ![](./screen/screen26.png)
        > что бы выйти из редактора без сохранения файла нужно:<br/>
        1: для выхода из редактора нужно нажать сочание клавиш `control + x`<br/>
        2: когда мы выходим из редактора, он предложит нам сохранить файл если в нем были сделданны изменения и нужно нажать `n`

        * скриншот редактора joe с содержимым файла
        ![](./screen/screen27.png)
        > что бы выйти из редактора без сохранения файла нужно:<br/>
        1: для выхода из редактора нужно нажать сочание клавиш `control + k` и `q`<br/>
        2: когда мы выходим из редактора, он предложит нам сохранить файл если в нем были сделданны изменения и нужно нажать `n`

    * Используем каждый из трех выбранных редакторов, отредактируем файл ещё раз (по аналогии с предыдущим пунктом), а затем освоим функции поиска по содержимому файла (слово) и замены слова на любое другое.
        * скриншот редактора vim с содержимым файла
            * с результатами поиска слова
            ![](./screen/screen28.png)

            * с командами, введёнными для замены слова на другое
            ![](./screen/screen29.png)

        * скриншот редактора nano с содержимым файла
            * с результатами поиска слова
            ![](./screen/screen30.png)

            * с командами, введёнными для замены слова на другое
            ![](./screen/screen31.png)

        * скриншот редактора joe с содержимым файла
            * с результатами поиска слова
            ![](./screen/screen32.png)

            * с командами, введёнными для замены слова на другое
            ![](./screen/screen33.png)

## 8. Установка и базовая настройка сервиса SSHD
* Устанавливаем службу SSHd
    * что бы установить SSHd нужно использовать команду: `sudo apt install openssh-server`

* Добавляем автостарт службы при загрузке системы
    * что бы это сделать нужно добавить его в автозагрузку командой `sudo systemctl enable sshd`

* Перенастраиваем службу SSHd на порт 2022
    * нам нужно найти файл sshd_config и изменить его с помощью редактора (в данном случае vim)<br/>
    Выполняем команду `vim /etc/ssh/sshd_config` и находим строку где написано `Port 22`.<br/>
    Если строка начинается с символа #, его нужно удалить и вместо 22 порта, написать любой другой, например `Port 2022`
    ![](./screen/screen34.png)

* Использем команду ps, показать наличие процесса sshd. Для этого к команде нужно подобрать ключи
    * ps - (process status) — программа в UNIX, Unix-подобных и других POSIX-совместимых операционных системах, ps выводит список текущих процессов на вашем сервере.
    * выводим наличие процесса командой `ps -fL -C sshd`
        * `-f` - вывести максимум доступных данных, например, количество потоков
        * `-L` - отображать потоки процессов в колонках LWP и NLWP
        * `-C` - выбирать процессы по имени команды
        * `sshd` - имя команды

        <br/>

        ![](./screen/screen35.png)

* Перезагружаем систему командой `reboot`

* Вывод команды `netstat -tan` должен содержать `tcp 0 0 0.0.0.0:2022 0.0.0.0:* LISTEN`
![](./screen/screen36.png)
> `-a или -all` - выводит информацию о всех сокетах(об активных которые слушают порты и неактивных, которые не слушают).<br/>
`-n или --numeric` - заставляет netstat печатать адреса, разделенные точками, вместо использования символических имен сетей.
`-t или --tcp` - по протоколу tcp.<br/><br/>
`Recv-Q` - количество байтов, не скопированных пользовательской программой, подключенной к этому сокету.<br/>
`Send-Q` - количество байтов, не подтвержденных удаленным хостом.<br/>
`Local Address` - Адрес и номер порта локального конца сокета. Если не указан параметр --numeric (-n), адрес сокета преобразуется в его каноническое имя хоста (FQDN), а номер порта преобразуется в соответствующее имя службы.<br/>
`Foreign Address` - адрес и номер порта удаленного конца сокета. Аналогичен «Local Address».<br/>
`State` - состояние сокета. Поскольку в необработанном режиме нет состояний и обычно состояния не используются в UDP, этот столбец можно оставить пустым.<br/>
`Proto` - протокол

## 9. Установка и использование утилит top, htop
* Устанавливаем и запускаем утилиты top и htop
    * для установки используем команды:<br/>
    1. установить top: `sudo apt install top`
    2. установить htop: `sudo apt install htop`

* По выводу команды top определить и написать в отчёте:
    ![](./screen/screen37.png)

    * uptime
    ![](./screen/screen38.png)

    * количество авторизованных пользователей
    ![](./screen/screen39.png)

    * общую загрузку системы
    ![](./screen/screen40.png)
    
    * общее количество процессов
    ![](./screen/screen41.png)
    > `total` - общее количество процессов в системе<br/>
    `running` — количество работающих в данный момент процессов<br/>
    `sleeping` — количество ожидающих событий процессов<br/>
    `stopped` — количество остановленных процессов<br/>
    `zombie` — количество процессов, ожидающих родительский процесс для передачи статуса завершения

    * загрузку cpu
    ![](./screen/screen42.png)
    > `us` — процент использования центрального процессора пользовательскими процессам<br/>
    `sy` — процент использования центрального процессора системными процессами<br/>
    `ni` — процент использования центрального процессора процессами с приоритетом, повышенным при помощи вызова<br/>
    `id` — процент времени, когда центральный процессор не используется<br/>
    `wa` — процент использования центрального процессора процессами, ожидающими завершения операций ввода-вывода<br/>
    `hi` - Hardware IRQ (аппаратные прерывания) — процент использования центрального процессора обработчиками аппаратных прерываний<br/>
    `si` - Software Interrupts (программные прерывания) — процент использования центрального процессора обработчиками программных прерываний<br/>
    `st` - Steal Time (заимствованное время) — количество ресурсов центрального процессора "заимствованных" у виртуальной машины гипервизором для других задач (таких, как запуск другой виртуальной машины); это значение будет равно нулю на настольных компьютерах и серверах, не использующих виртуальные машины

    * загрузку памяти
    ![](./screen/screen43.png)
    > выводится информация об использовании физической оперативной памяти и раздела подкачки соответственно `swap`<br/>
    `total` - общее количество памяти<br/>
    `used` - количество используемой памяти<br/>
    `free` - количество свободной памяти<br/>
    `buffers` - количество памяти в кэше буферов<br/>

    * pid процесса занимающего больше всего памяти
    ![](./screen/screen44.png)

    * pid процесса, занимающего больше всего процессорного времени
    ![](./screen/screen45.png)
    > `PID` - номер процесса<br/>
    `USER` - имя пользователя<br/>
    `PR` - какой приоритет имеет процесс в данный момент<br/>
    `NI` - приоритет, присвоенный ему командой `NICE`<br/>
    `VIRT` — виртуальная память, которую использует процесс<br/>
    `RES` — физическая память, занятая данным процессом<br/>
    `SHR` — общий объем памяти, которую данный процесс делит с другими<br/>
    `S` — текущий статус процесса: R — running; S — sleeping, Z — zombie<br/>
    `%CPU` — процент используемого времени центрального процессора<br/>
    `%MEM` — процент ОЗУ, используемой процессом<br/>
    `TIME+` — продолжительность работы процесса с момента запуска<br/>
    `COMMAND` — название команды (программы), которая инициировала процесс.<br/>

* В отчёт вставить скрин с выводом команды htop:
    * Вводим команду `htop`
    ![](./screen/screen50.png)
    * отсортированному по PID, PERCENT_CPU, PERCENT_MEM, TIME
        * PID
        ![](./screen/screen46.png)

        * PERCENT_CPU
        ![](./screen/screen47.png)

        * PERCENT_MEM
        ![](./screen/screen48.png)

        * TIME
        ![](./screen/screen49.png)

    * отфильтрованному для процесса sshd
    ![](./screen/screen51.png)

    * с процессом syslog, найденным, используя поиск
    ![](./screen/screen52.png)

    * с добавленным выводом hostname, clock и uptime
    ![](./screen/screen53.png)

## 10. Использование утилиты fdisk
* Запускаем команду fdisk -l
![](./screen/screen54.png)

## 11. Использование утилиты df
* Запускаем команду df
    * В отчёте написать для корневого раздела (/):
    ![](./screen/screen55.png)
    `7379852` - размер раздела<br/>
    `3966316` - размер занятого пространства<br/>
    `3017248` - размер свободного пространства<br/>
    `57%` - процент использования<br/>
    Единица измерения в виводе - Килобайт

* Запускаем команду df -Th
    * В отчёте написать для корневого раздела (/):
    ![](./screen/screen56.png)
    `7.1G` - размер раздела<br/>
    `3.8` - размер занятого пространства<br/>
    `2.9` - размер свободного пространства<br/>
    `48%` - процент использования<br/>
    `ext4` - тип файловой системы для раздела<br/>
    <br/>
    Чтобы отобразить информацию о дисках в удобночитаемом формате (килобайты, мегабайты, гигабайты и т. д...) надо вызвать команды df с параметром `-h`<br/>
    `-T` - указывает df отоброжать типы файловых систем

## 12. Использование утилиты du
* Запускаем команду du
![](./screen/screen57.png)

* Выводим размер папок /home, /var, /var/log (в байтах, в человекочитаемом виде)
![](./screen/screen58.png)

* Выводим размер всего содержимого в /var/log (не общее, а каждого вложенного элемента, используя *)
![](./screen/screen59.png)

## 13. Установка и использование утилиты ncdu
* Устанавливаем утилиту ncdu
![](./screen/screen60.png)

* Выводим размер папок /home, /var, /var/log
    * /home
    ![](./screen/screen61.png)

    * /var
    ![](./screen/screen62.png)

    * /var/log
    ![](./screen/screen63.png)

## 14. Работа с системными журналами
* Написать в отчёте время последней успешной авторизации, имя пользователя и метод входа в систему
![](./screen/screen64.png)
> `Jul 20 14:07:38` - время последней успешной авторизации<br/>
`lucankri` - имя пользователя<br/>
`by LOGIN` - метод входа в систему<br/>

* Перезапускаем службу SSHd
![](./screen/screen65.png)

* Вставить в отчёт скрин с сообщением о рестарте службы (искать в логах)
![](./screen/screen66.png)

## 15. Использование планировщика заданий CRON
* Используем планировщик заданий, запускаем команду uptime через каждые 2 минуты
    ![](./screen/screen67.png)

    * Найти в системных журналах строчки (минимум две в заданном временном диапазоне) о выполнении
    ![](./screen/screen68.png)

    * Вывести на экран список текущих заданий для CRON
    ![](./screen/screen69.png)

* Удалите все задания из планировщика заданий
![](./screen/screen70.png)